guid,original,title,remarks,sources,settings,text1,text2,text3,text4,text5,text6,text7,text8,text9,text10,text11,text12,text13,text14,text15,text16,text17,text18,text19,text20,full,tags
nXyxR5FIdN,"<ul><li>Divide heap into a fixed partition based on allocation site (the statement label)</li><li>All objects located at the same program point (label get represented by a single ""abstract object""</li></ul>",How to handle dynamically allocated objects:,"<img src=""paste-dcf031581a2d8e864ded340b1e24747a9b0e332f.jpg""><br><img src=""paste-e4ee92045b6c2c5267ea1f031151bc83246e99c0.jpg"">",,"0,1,0 | n,n,n,n",<ul><li>{{c1::Divide heap into a fixed partition based on allocation site (the statement label)}}</li><li>...</li></ul>,"<ul><li>...</li><li>{{c2::All objects located at the same program point (label get represented by a single ""abstract object""}}</li></ul>",<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,"<ul><li>{{c21::Divide heap into a fixed partition based on allocation site (the statement label}}</li><li>{{c21::All objects located at the same program point (label get represented by a single ""abstract object""}}</li></ul>",eth::sem6::rse
RaBa4gSgSW,<ol><li>Compute all reachable&nbsp;abstract&nbsp;states</li><li>Check if abstract states are&nbsp;data-race free&nbsp;(no read-write conflicts)</li></ol>,Steps to check (Abstract) Data-Race-Freedom:,,,"0,1,0 | n,n,n,n",<ol><li>{{c1::Compute all reachable abstract states}}</li><li>...</li></ol>,<ol><li>...</li><li>{{c2::Check if abstract states are data-race free (no read-write conflicts)}}</li></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol><li>{{c21::Compute all reachable abstract states}}</li><li>{{c21::Check if abstract states are data-race free (no read-write conflicts)}}</li></ol>,eth::sem6::rse
cR0Bd;]B<e,<ul><li>maps variables to symbolic expressions</li><li>is used to evaluate program expressions to symbolic exprs.</li><li>is updated by assignment statements</li></ul>,A symbolic store&nbsp;\(\sigma\):,"<img src=""paste-895ace1b661f4db5c33b8ca798be3c89f5e8e0de.jpg"">",,"1,1,0 | n,n,n,n",<ul><li>{{c1::maps variables to symbolic expressions}}</li><li>...</li><li>...</li></ul>,<ul><li>maps variables to symbolic expressions</li><li>{{c2::is used to evaluate program expressions to symbolic exprs.}}</li><li>...</li></ul>,<ul><li>...</li><li>is used to evaluate program expressions to symbolic exprs.</li><li>{{c3::is updated by assignment statements}}</li></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul></ul>,<ul><li>{{c21::maps variables to symbolic expressions}}</li><li>{{c21::is used to evaluate program expressions to symbolic exprs.}}</li><li>{{c21::is updated by assignment statements}}</li></ul>,eth::sem6::rse
q4!2q+a_<x,"<ol><li>Start with an initial symbolic state</li><li>Propagate this across all statements, i.e. symbolically execute the program</li><li>Duplicate the current state at branch points: one copy per branch</li><li>When following a branch, add the corresponding condition to the state</li><li>Eventually, we’ll have a final state per path</li><li>Per final state, solve the path conditions to obtain test inputs that exercise the path<br></li></ol>",Symbolic Execution Algorithm,"<img src=""paste-9fcb15b1676491fded7238f27ff970ab7304de3c.jpg"">",,"2,1,0 | n,n,n,n",<ol><li>{{c1::Start with an initial symbolic state}}</li><li>...</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>,"<ol><li>Start with an initial symbolic state</li><li>{{c2::Propagate this across all statements, i.e. symbolically execute the program}}</li><li>...</li><li>...</li><li>...</li><li>...</li></ol>","<ol><li>Start with an initial symbolic state</li><li>Propagate this across all statements, i.e. symbolically execute the program</li><li>{{c3::Duplicate the current state at branch points: one copy per branch}}</li><li>...</li><li>...</li><li>...</li></ol>","<ol><li>...</li><li>Propagate this across all statements, i.e. symbolically execute the program</li><li>Duplicate the current state at branch points: one copy per branch</li><li>{{c4::When following a branch, add the corresponding condition to the state}}</li><li>...</li><li>...</li></ol>","<ol><li>...</li><li>...</li><li>Duplicate the current state at branch points: one copy per branch</li><li>When following a branch, add the corresponding condition to the state</li><li>{{c5::Eventually, we’ll have a final state per path}}</li><li>...</li></ol>","<ol><li>...</li><li>...</li><li>...</li><li>When following a branch, add the corresponding condition to the state</li><li>Eventually, we’ll have a final state per path</li><li>{{c6::Per final state, solve the path conditions to obtain test inputs that exercise the path}}</li></ol>",<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,<ol></ol>,"<ol><li>{{c21::Start with an initial symbolic state}}</li><li>{{c21::Propagate this across all statements, i.e. symbolically execute the program}}</li><li>{{c21::Duplicate the current state at branch points: one copy per branch}}</li><li>{{c21::When following a branch, add the corresponding condition to the state}}</li><li>{{c21::Eventually, we’ll have a final state per path}}</li><li>{{c21::Per final state, solve the path conditions to obtain test inputs that exercise the path}}</li></ol>",eth::sem6::rse
